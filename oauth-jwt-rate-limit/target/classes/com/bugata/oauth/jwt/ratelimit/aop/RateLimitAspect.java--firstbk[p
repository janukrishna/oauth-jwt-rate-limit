package com.bugata.oauth.jwt.ratelimit.aop;

import java.time.Duration;
import java.time.Instant;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import javax.servlet.http.HttpServletRequest;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

@Aspect
@Component
public class RateLimitAspect {

	private final Map<String, Instant> requestTimestamps = new ConcurrentHashMap<>();
	private final Map<String, Integer> requestCounts = new ConcurrentHashMap<>();

	@Value("${ratelimit.window.seconds}")
	private int rateLimitWindowSeconds;

	@Value("${ratelimit.max.requests}")
	private int rateLimitMaxRequests;

	@Before("@annotation(com.bugata.oauth.jwt.ratelimit.config.RateLimit)")
	public ResponseEntity<?> rateLimitCheck() {
		ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder
				.getRequestAttributes();
		HttpServletRequest request = requestAttributes.getRequest();

		String clientId = request.getHeader("X-Client-Id");
		String endpoint = request.getRequestURI();

		String key = clientId + ":" + endpoint;
		key="krnsa";
		System.out.println(key);
		Instant now = Instant.now();

		// Remove expired entries from requestTimestamps
		requestTimestamps.entrySet()
				.removeIf(entry -> entry.getValue().isBefore(now.minusSeconds(rateLimitWindowSeconds)));

		// Increment request count for the client and endpoint
		requestCounts.putIfAbsent(key, 0);
		requestCounts.computeIfPresent(key, (k, v) -> v + 1);

		int requestCount = requestCounts.get(key);

		// Check if request count exceeds rate limit
		if (requestCount > rateLimitMaxRequests) {
			HttpHeaders headers = new HttpHeaders();
			headers.add("RateLimit-Limit", String.valueOf(rateLimitMaxRequests));
			headers.add("RateLimit-Remaining", "0");
			headers.add("RateLimit-Reset", String.valueOf(calculateResetTime()));

			return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS).headers(headers)
					.body("Rate limit exceeded. Try again later.");
		}

		// Update request timestamp for the client and endpoint
		requestTimestamps.put(key, now);

		// Calculate Retry-After based on rate limit window
		HttpHeaders headers = new HttpHeaders();
		headers.add("RateLimit-Limit", String.valueOf(rateLimitMaxRequests));
		headers.add("RateLimit-Remaining", String.valueOf(rateLimitMaxRequests - requestCount));
		headers.add("RateLimit-Reset", String.valueOf(calculateResetTime()));
		headers.add("Retry-After", String.valueOf(calculateRetryAfter()));
		System.out.println(headers);
		return null; // Proceed with the method execution
	}

	private long calculateResetTime() {
		Instant oldestRequestTime = Instant.now().minusSeconds(rateLimitWindowSeconds);
		Instant nextResetTime = oldestRequestTime.plusSeconds(rateLimitWindowSeconds);
		return Duration.between(Instant.now(), nextResetTime).getSeconds();
	}

	private long calculateRetryAfter() {
		return rateLimitWindowSeconds;
	}
}
